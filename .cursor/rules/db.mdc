---
alwaysApply: true
---
# **📝 양조장 제어 시스템 DB 모듈 PRD**

## **1. 📌 개요**

**1.1 목적**

본 문서는 라즈베리파이 4 기반의 제어 시스템에서 발생하는 센서 및 상태 데이터를 저장, 관리, 조회하기 위한 데이터베이스 모듈의 요구사항과 설계를 정의한다.

### **1.2 핵심 목표**

- **고성능:** 1초 주기의 다량 데이터(약 20개 이상의 센서 값)를 지연 없이 저장.
- **효율성:** 라즈베리파이 4의 리소스(CPU/RAM) 사용 최소화 (SQLite 사용).
- **활용성:** 웹 대시보드 그래프 시각화 및 CSV 데이터 추출을 위한 유연한 조회 기능 제공.
- **안정성:** 저장 용량 초과 시 자동 관리(Retention Policy) 및 트랜잭션 보장.

---

## **2. 🏗️ 데이터베이스 스키마 설계 (SQLite)**

데이터의 중복을 최소화하고 조회 속도를 극대화하기 위해 **Master-Detail 구조**로 3개의 테이블을 구성한다.

### **2.1 Entity Relationship**

- **Packets (Master):** 데이터가 수신된 시점(Timestamp)과 패킷 순서 정보를 저장.
- **Readings (Detail 1):** 실제 센서 값(VALUES)을 저장. (1 Packet : N Readings)
- **States (Detail 2):** 탱크별 상태 정보(STATE)를 저장. (1 Packet : N States)

**2.2 Table Definitions**

**1) packets (메인 로그 테이블)**

| Field | Type | Description | Note |
| --- | --- | --- | --- |
| id | INTEGER | Primary Key | Auto Increment |
| order_num | INTEGER | 패킷 순서 번호 | JSON의 ORDER |
| created_at | DATETIME | 생성 일시 | DATE + TIME (YYYY-MM-DD HH:MM:SS) |
- **Index:** idx_packets_created_at (기간 조회를 위해 필수)

**2) readings (센서 데이터 테이블)**

| Field | Type | Description | Note |
| --- | --- | --- | --- |
| id | INTEGER | Primary Key | Auto Increment |
| packet_id | INTEGER | Foreign Key | packets.id 참조 |
| tank_id | TEXT | 탱크 ID | 예: "100", "101" (문자열 통일) |
| sensor_id | INTEGER | 센서 ID | 예: 100, 101, 200 |
| value | REAL | 센서 값 | 숫자형 저장 (그래프 용) |
- **Index:** idx_readings_tank_sensor (탱크+센서별 고속 조회를 위해 필수)

**3) states (상태 데이터 테이블)**

| Field | Type | Description | Note |
| --- | --- | --- | --- |
| id | INTEGER | Primary Key | Auto Increment |
| packet_id | INTEGER | Foreign Key | packets.id 참조 |
| tank_id | TEXT | 탱크 ID | 예: "100" |
| stage | INTEGER | 공정 단계 | 예: 0, 100, 201 |
| status | TEXT | 상태 문자열 | 예: "Run", "Pause" |

---

## **3. ⚙️ 기능 요구사항**

### **3.1 데이터 수집 및 저장 제어**

1. **조건부 저장 (Recording Control):**
- DB 저장은 **항상 수행되는 것이 아님**.
- 시스템 내부에 is_recording 플래그를 둔다.
- **Start:** 프론트엔드에서 '레시피 시작' 버튼 클릭 시 → is_recording = True
- **Stop:** 프론트엔드에서 '레시피 정지' 버튼 클릭 시 → is_recording = False
1. **데이터 파싱:**
- 수신된 JSON의 DATE와 TIME을 결합하여 표준 Timestamp 포맷으로 변환.
- VALUES 배열을 순회하며 readings 테이블에 Bulk Insert.
- STATE 배열을 순회하며 states 테이블에 Bulk Insert.
- 모든 저장은 **비동기(Async)**로 수행하여 메인 통신 루프를 차단하지 않아야 함.

### **3.2 데이터 조회 (대시보드용)**

1. **필터링 조건:**
- **기간 (Time Range):** 시작 일시 ~ 종료 일시
- **대상 (Target):** 특정 TANK_ID
- **항목 (Items):** 특정 SENSOR_ID (단일 혹은 복수 선택)
1. **응답 데이터:**
- 그래프 라이브러리(Recharts 등)가 즉시 사용할 수 있는 형태의 JSON 배열 반환.
- 예: [{time: "09:08:07", value: 20.2}, {time: "09:08:08", value: 20.5}, ...]

### **3.3 데이터 내보내기 (CSV Export)**

1. **요청 파라미터:** 시작 일시, 종료 일시.
2. **생성 포맷:**
- 컬럼: Timestamp, Tank_ID, Sensor_ID, Value, Stage, Status
- 또는 사용자가 보기 편한 Pivot 형태 (행: 시간, 열: 센서들) 지원 고려.
1. **프로세스:**
- 요청 시 백엔드에서 SQLite 쿼리 실행 -> Pandas 등을 이용해 CSV 변환 -> 파일 다운로드 응답.

### **3.4 데이터 유지 관리 (Retention Policy)**

1. **용량 제한:**
- 설정 파일(sys.ini)에 MAX_DB_SIZE_MB (예: 500MB) 또는 MAX_RETENTION_DAYS (예: 30일) 설정.
1. **자동 삭제 (Auto Cleanup):**
- 주기적(예: 1시간마다 또는 앱 시작 시)으로 DB 크기 체크.
- 임계치 초과 시, created_at이 가장 오래된 데이터부터 삭제 (FIFO).
- packets 테이블에서 삭제 시 ON DELETE CASCADE 설정을 통해 하위 데이터 자동 삭제.

---

## **4. 🔌 API 인터페이스 설계 (Draft)**

**4.1 제어 API**

| Method | Endpoint | Description | Payload |
| --- | --- | --- | --- |
| POST | /api/recording/start | DB 저장 시작 | { "recipe_id": "..." } |
| POST | /api/recording/stop | DB 저장 중지 | - |
| GET | /api/recording/status | 현재 저장 중인지 확인 | - |

**4.2 조회 API**

| Method | Endpoint | Description | Query Params |
| --- | --- | --- | --- |
| GET | /api/history/chart | 그래프용 데이터 조회 | tank_id, sensor_ids (list), start, end |
| GET | /api/history/export | CSV 다운로드 | start, end |

---

## **5. ⚠️ 기술적 고려사항**

1. **Concurrency (동시성):**
- aiosqlite 라이브러리를 사용하여 Python asyncio 환경에서 Non-blocking I/O를 보장해야 함.
1. **Data Type Consistency:**
- JSON 상에서 TANK_ID가 숫자(100)와 문자("100")로 혼용될 수 있으므로, DB 저장 시 반드시 **String(TEXT)** 타입으로 캐스팅하여 저장한다.
1. **Indexing:**
- 조회 성능의 90%는 인덱스에서 결정됨. created_at과 tank_id 컬럼에 반드시 인덱스를 생성해야 함.

---

## **6. 📨 수신 데이터 포맷 (Protocol Example)**

TCP Bridge(handle_receiver_connection)를 통해 수신되는 원본 JSON 데이터 형식은 다음과 같다.

{

"CMD": "SENSOR",

"ORDER": 1535,

"DATE": "2023-06-16",

"TIME": "09:08:07",

"VALUES": [

{"TANK_ID": "100", "SENSOR_ID": 100, "VALUE": "20.2"},

{"TANK_ID": "100", "SENSOR_ID": 101, "VALUE": "19.8"},

{"TANK_ID": "100", "SENSOR_ID": 102, "VALUE": "20.2"},

{"TANK_ID": "100", "SENSOR_ID": 103, "VALUE": "19.9"},

{"TANK_ID": "100", "SENSOR_ID": 200, "VALUE": "50.6"},

{"TANK_ID": "100", "SENSOR_ID": 201, "VALUE": "49.7"},

{"TANK_ID": "100", "SENSOR_ID": 400, "VALUE": "200.0"},

{"TANK_ID": "100", "SENSOR_ID": 500, "VALUE": "001"},

{"TANK_ID": "100", "SENSOR_ID": 501, "VALUE": "001"},

{"TANK_ID": "101", "SENSOR_ID": 100, "VALUE": "19.8"},

{"TANK_ID": "101", "SENSOR_ID": 101, "VALUE": "20.2"},

{"TANK_ID": "101", "SENSOR_ID": 102, "VALUE": "19.9"},

{"TANK_ID": "101", "SENSOR_ID": 103, "VALUE": "20.2"},

{"TANK_ID": "101", "SENSOR_ID": 200, "VALUE": "49.7"},

{"TANK_ID": "101", "SENSOR_ID": 201, "VALUE": "50.7"},

{"TANK_ID": "101", "SENSOR_ID": 400, "VALUE": "150.0"},

{"TANK_ID": "101", "SENSOR_ID": 500, "VALUE": "001"},

{"TANK_ID": "101", "SENSOR_ID": 501, "VALUE": "001"}

],

"STATE": [

{"TANK_ID": 100, "STAGE": 0, "STATUS": "None"},

{"TANK_ID": 101, "STAGE": 100, "STATUS": "Pause"},

{"TANK_ID": 102, "STAGE": 201, "STATUS": "Run"},

{"TANK_ID": 103, "STAGE": 300, "STATUS": "Pause"}

]

}